
/*
 * Copyright (c) 2001-2013 Aspose Pty Ltd. All Rights Reserved.
 */

package com.aspose.ecplugin;



import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;

import org.eclipse.core.resources.ICommand;
import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IProjectDescription;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.ui.dialogs.FileSelectionDialog;


import com.aspose.ecplugin.AsposeComponentsManager;

public class CustomProjectSupport {
	/**
	 * For this marvelous project we need to:
	 * - create the default Eclipse project
	 * - add the custom project nature
	 * - create the folder structure
	 *
	 * @param projectName
	 * @param location
	 * @param natureId
	 * @return
	 */
	public static IProject createProject(String projectName, URI location) {
		Assert.isNotNull(projectName);
		Assert.isTrue(projectName.trim().length() > 0);

		IProject project = createBaseProject(projectName, location);
		//project.
		try {
			addNature(project,ECPluginConstants.NATURE_ID);
			addNature(project,ECPluginConstants.NATURE_ID_JDT);
			addBuildCommand(project);
			String[] paths = { ECPluginConstants.SRC_FOLDER, ECPluginConstants.BIN_FOLDER,ECPluginConstants.LIB_FOLDER };
			addToProjectStructure(project, paths);
			//downloadLibrary(project, "aspose-words.jar","https://apps.codeporting.com/scripts/");
			//downloadLibrary(project, "download.aspx","http://www.aspose.com/community/files/417146/");
			addClassPath(project);
			project.refreshLocal(0, null);

		} catch (CoreException e) {
			e.printStackTrace();
			project = null;
		}

		return project;
	}

	public static void downloadLibrary(IProject project, String libName, String URL)
	{
		URL website;
		try {
			IJavaProject javaProject = JavaCore.create(project);


			IFolder libFolder = project.getFolder(ECPluginConstants.LIB_FOLDER);			
			IPackageFragmentRoot libRoot = javaProject.getPackageFragmentRoot(libFolder);
			IPath libFolderPath = libRoot.getPath();
			//IPath ipathP = libRoot.getParent().getPath();
			IPath workspacePath = ResourcesPlugin.getWorkspace().getRoot().getLocation();
			IPath absoluteLibFolderPath=workspacePath.append(libFolderPath);
			@SuppressWarnings("unused")
			String libraryPath = absoluteLibFolderPath.toString();
			String combPath = "lib" + "/" + libName;
			IFile iFile= project.getFile(combPath);
			
			//file.set
			website = new URL(URL + libName);

			ReadableByteChannel rbc;

			rbc = Channels.newChannel(website.openStream());

			FileOutputStream fos;
			java.io.File file = iFile.getLocation().toFile();
			fos = new FileOutputStream(file);

			fos.getChannel().transferFrom(rbc, 0, 1 << 24);
			fos.close();
			try {
				iFile.refreshLocal(0, null);
			} catch (CoreException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * 
	 * @param project
	 * @throws JavaModelException
	 */
	public static void addClassPath(IProject project) throws JavaModelException
	{
		IJavaProject javaProject = JavaCore.create(project);
		IClasspathEntry[] newEntries = new IClasspathEntry[ 3];

		// add a new entry using the path to the container
		Path junitPath = new Path(ECPluginConstants.ORG_ECLIPSE_JDT_LAUNCHING_CONTAINER);
		IClasspathEntry junitEntry = JavaCore.newContainerEntry(junitPath);
		newEntries[0] = JavaCore.newContainerEntry(junitEntry.getPath());

		//add src folder
		IFolder sourceFolder = project.getFolder(ECPluginConstants.SRC_FOLDER);
		IPackageFragmentRoot srcRoot = javaProject.getPackageFragmentRoot(sourceFolder);
		IClasspathEntry srcPathEntry = JavaCore.newSourceEntry(srcRoot.getPath());
		newEntries[1] = srcPathEntry;

		//Add lib folder	
		//IFolder libFolder = project.getFolder(ECPluginConstants.LIB_FOLDER);
		IFolder libFolder = project.getFolder(ECPluginConstants.LIB_FOLDER);
		IPackageFragmentRoot libRoot = javaProject.getPackageFragmentRoot(libFolder);
		//IPackageFragmentRoot libRoot = javaProject.getPackageFragmentRoot(libFolder);
		IPath libFolderPath = libRoot.getPath();
		
		IPath workspacePath = ResourcesPlugin.getWorkspace().getRoot().getLocation();
		IPath absoluteLibFolderPath=workspacePath.append(libFolderPath);
		@SuppressWarnings("unused")
		String libraryPath = absoluteLibFolderPath.toString();
		for(AsposeJavaComponent component:AsposeJavaComponents.list.values())
		{
			if(component.is_selected() && component.is_downloaded())
			{
				String downloadedLib =	AsposeComponentsManager.getLibaryDownloadPath() + component.get_downloadFileName();
				String projectLib = libFolderPath.toOSString();//libraryPath  + "/" + component.get_downloadFileName();
				String projectLib2 = workspacePath.toOSString() + "/"+ project.getName() + "/bin/lib/" + component.get_downloadFileName();
				copyAsResource(project, downloadedLib, projectLib);
				//copyFile(downloadedLib, projectLib);
				//copyFile(downloadedLib, projectLib2);
				
				//IFile iFile= project.getFile(combPath);
			}
		}

		try {
			//libFolder.refreshLocal(0, null);
			IResource[] libFiles = libFolder.members();
			for(int i=0; i< libFiles.length;i++)
			{
				String libName =	libFiles[i].getName();
				IClasspathEntry libPathEntry = JavaCore.newLibraryEntry(libRoot.getPath().append(libName),libRoot.getPath().append(libName),null);
				newEntries[i+2] = libPathEntry;
			}

			javaProject.setRawClasspath(newEntries, null);
		} catch (CoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		


	}

	private static boolean copyAsResource(IProject project, String srcPath, String destPath)
	{
		try {
		InputStream is = new BufferedInputStream(new FileInputStream(srcPath));
	    IFile file = project.getFile(destPath);
	    
			file.create(is, false, null);
		

	    IPath path = file.getFullPath();
	    //libraries.add(JavaCore.newLibraryEntry(path, null, null));
	    //add libs to project class path
	    return true;
		} catch (CoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return false;
		}
	    //try {
	       //javaProject.setRawClasspath(libraries.toArray(new IClasspathEntry[libraries.size()]), null);
	    //} catch (JavaModelException e1) {
	      // e1.printStackTrace();
	       //return false;
	    //}
 catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return false;
		}
	}
	/**
	 * 
	 * @param srcPath
	 * @param destPath
	 * @return
	 */
	private static boolean  copyFile(String srcPath, String destPath)
	{
		try
		{			
			InputStream in = new FileInputStream(srcPath);
			OutputStream out = new FileOutputStream(destPath);
			byte[] buf = new byte[1024];
			int len;
			while ((len = in.read(buf)) > 0) {
				out.write(buf, 0, len);
			}
			in.close();
			out.close();
			return true;

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return false;
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return false;
		}
	}

	/**
	 * Just do the basics: create a basic project.
	 *
	 * @param location
	 * @param projectName
	 */
	private static IProject createBaseProject(String projectName, URI location) {
		// it is acceptable to use the ResourcesPlugin class
		IProject newProject = ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);

		if (!newProject.exists()) {
			URI projectLocation = location;
			IProjectDescription desc = newProject.getWorkspace().newProjectDescription(newProject.getName());
			if (location != null && ResourcesPlugin.getWorkspace().getRoot().getLocationURI().equals(location)) {
				projectLocation = null;
			}

			desc.setLocationURI(projectLocation);
			try {
				newProject.create(desc, null);
				if (!newProject.isOpen()) {
					newProject.open(null);
				}
			} catch (CoreException e) {
				e.printStackTrace();
			}
		}

		return newProject;
	}

	/**
	 * 
	 * @param folder
	 * @throws CoreException
	 */
	private static void createFolder(IFolder folder) throws CoreException {
		IContainer parent = folder.getParent();
		if (parent instanceof IFolder) {
			createFolder((IFolder) parent);
		}
		if (!folder.exists()) {
			folder.create(false, true, null);
		}
	}

	/**
	 * Create a folder structure with a parent root, overlay, and a few child
	 * folders.
	 *
	 * @param newProject
	 * @param paths
	 * @throws CoreException
	 */
	private static void addToProjectStructure(IProject newProject, String[] paths) throws CoreException {
		for (String path : paths) {
			IFolder etcFolders = newProject.getFolder(path);
			createFolder(etcFolders);
		}
	}

	/**
	 * 
	 * @param project
	 * @param natureId
	 * @throws CoreException
	 */
	private static void addNature(IProject project, String natureId) throws CoreException {
		if (!project.hasNature(natureId)) {
			IProjectDescription description = project.getDescription();
			String[] prevNatures = description.getNatureIds();
			String[] newNatures = new String[prevNatures.length + 1];
			System.arraycopy(prevNatures, 0, newNatures, 0, prevNatures.length);
			newNatures[prevNatures.length] = natureId;
			description.setNatureIds(newNatures);

			IProgressMonitor monitor = null;
			project.setDescription(description, monitor);
		}
	}

	/**
	 * 
	 * @param project
	 * @throws CoreException
	 */
	private static void addBuildCommand(IProject project) throws CoreException {
		IProjectDescription description = project.getDescription();
		ICommand[] buildCommands = description.getBuildSpec();
		ICommand command = description.newCommand();
		command.setBuilderName(ECPluginConstants.ORG_ECLIPSE_JDT_CORE_JAVA_BUILDER);

		ICommand[] newBuildCommands;
		if ( contains( buildCommands, ECPluginConstants.ORG_ECLIPSE_JDT_CORE_JAVA_BUILDER ) ) {
			newBuildCommands = swap( buildCommands, ECPluginConstants.ORG_ECLIPSE_JDT_CORE_JAVA_BUILDER, command );
		} else {
			newBuildCommands = insert( buildCommands, command );
		}			

		description.setBuildSpec(newBuildCommands);
		project.setDescription(description, null);
	}

	/**
	 * 
	 * @param sourceCommands
	 * @param command
	 * @return
	 */
	private static ICommand[] insert( ICommand[] sourceCommands, ICommand command ) {
		ICommand[] newCommands = new ICommand[ sourceCommands.length + 1 ];
		newCommands[0] = command;
		for (int i = 0; i < sourceCommands.length; i++ ) {
			newCommands[i+1] = sourceCommands[i];
		}		
		return newCommands;		
	}

	/**
	 * 
	 * @param sourceCommands
	 * @param builderId
	 * @return
	 */
	@SuppressWarnings("unused")
	private static ICommand[] remove( ICommand[] sourceCommands, String builderId ) {
		ICommand[] newCommands = new ICommand[ sourceCommands.length - 1 ];
		int newCommandIndex = 0;
		for (int i = 0; i < sourceCommands.length; i++ ) {
			if ( !sourceCommands[i].getBuilderName( ).equals( builderId ) ) {
				newCommands[newCommandIndex++] = sourceCommands[i];
			}
		}		
		return newCommands;		
	}

	/**
	 * 
	 * @param commands
	 * @param builderId
	 * @return
	 */
	private static boolean contains(ICommand[] commands, String builderId) {
		boolean found = false;
		for (int i = 0; i < commands.length; i++) {
			if (commands[i].getBuilderName().equals(builderId)) {
				found = true;
				break;
			}
		}
		return found;
	}

	/**
	 * 
	 * @param sourceCommands
	 * @param oldBuilderId
	 * @param newCommand
	 * @return
	 */
	private static ICommand[] swap(
			ICommand[] sourceCommands,
			String oldBuilderId,
			ICommand newCommand) 
	{
		ICommand[] newCommands = new ICommand[sourceCommands.length];
		for ( int i = 0; i < sourceCommands.length; i++ ) {
			if ( sourceCommands[i].getBuilderName( ).equals( oldBuilderId ) ) {
				newCommands[i] = newCommand;
			} else {
				newCommands[i] = sourceCommands[i];
			}
		}	
		return newCommands;	
	}

}
